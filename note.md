### 一、进程创建

#### fork()函数

该函数创建一个新进程，父子进程分别以不同的返回值从fork()返回，子进程的返回值是0，父进程的返回值是子进程的PID，若进程创建失败，fork()返回-1.

fork()不是从#include处开始复制代码的，只是把进程当前的情况拷贝一份，只拷贝下一个要执行的代码到新的进程。

#### vfork()函数

类似于fork()函数，与fork()的调用相同而且有相同的返回值，子进程共享父进程的的地址空间，不创建副本，因此vfork()效率更高，速度特别快。

vfork()并不允许父子进程相互独立地运行，vfork()在出借父进程的地址空间给子进程的同时阻塞父进程，父进程被悬挂知道子进程调用了exec()或_exit()，此时内核返回地址空间给父进程并唤醒它。

#### 僵尸进程

在Linux进程的状态中，僵尸进程是非常特殊的一种，***它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度***，仅仅在进程列表中保留一个位 置，记载该进程的退出状态等信息供其他进程收集。除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装 SIGCHLD 信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，***如果这时父进程结束了， 那么init进程自动会接手这个子进程，为它收尸***，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是 为什么系统中有时会有很多的僵尸进程。

### 二、执行一个新程序

（1）exec函数说明

fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们**希望子进程去执行另外的程序**，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。

 

（2）在Linux中使用exec函数族主要有以下两种情况

当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生。

如果一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。

 

（3）exec函数族语法

实际上，在Linux中并没有exec函数，而是有6个以exec开头的函数族，下表列举了exec函数族的6个成员函数的语法。

| 所需头文件                                                   | #include <unistd.h>                                   |
| :----------------------------------------------------------- | ----------------------------------------------------- |
| 函数说明                                                     | 执行文件                                              |
| 函数原型                                                     | int execl(const char *pathname, const char *arg, ...) |
| int execv(const char *pathname, char *const argv[])          |                                                       |
| int execle(const char *pathname, const char *arg, ..., char *const envp[]) |                                                       |
| int execve(const char *pathname, char *const argv[], char *const envp[]) |                                                       |
| int execlp(const char *filename, const char *arg, ...)       |                                                       |
| int execvp(const char *filename, char *const argv[])         |                                                       |
| 函数返回值                                                   | 成功：函数不会返回                                    |
| 出错：返回-1，失败原因记录在error中                          |                                                       |

### 三、等待进程完成

 1) wait()函数用于使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数就会立即返回。

 2) waitpid()的作用和wait()一样，但它并不一定要等待第一个终止的子进程（它可以指定需要等待终止的子进程），它还有若干选项，如可提供一个非阻塞版本的 wait()功能，也能支持作业控制。实际上，wait()函数只是 waitpid()函数的一个特例，在[Linux](http://lib.csdn.net/base/linux) 内部实现 wait()函数时直接调用的就是waitpid()函数。